<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">typhonjs-core-multistorage/src/platforms/browser/MultiStorage.js | typhonjs-core-multistorage API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/typhonjs/typhonjs-core-multistorage/typhonjs-core-multistorage.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">src/platforms/browser</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/typhonjs-core-multistorage/src/platforms/browser/MultiStorage.js~MultiStorage.html">MultiStorage</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">src/platforms/node</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/typhonjs-core-multistorage/src/platforms/node/MultiStorage.js~MultiStorage.html">MultiStorage</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">typhonjs-core-multistorage/src/platforms/browser/MultiStorage.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

/**
 * Provides short or long term storage via Window.localStorage or Window.sessionStorage.
 */
export default class MultiStorage
{
   /**
    * Gets the main key.
    * @returns {*}
    */
   get mainKey() { return this._params.mainKey; }

   /**
    * Gets the serializer.
    * @returns {*}
    */
   get serializer() { return this._params.serializer; }

   /**
    * Get storage type.
    * @returns {*}
    */
   get storageType() { return this._params.storageType; }

   /**
    * Initializes MultiStorage. First parameter may be an optional object literal hash.
    *
    * @param {string}   mainKey - Main key to store items for this MultiStorage instance.
    * @param {boolean}  session - Boolean to indicate session (short term) storage; default is long term (localStorage).
    * @param {Object}   serializer - Instance that conforms to JSON serialization.
    */
   constructor(mainKey = &apos;multistorage&apos;, session = false, serializer = JSON)
   {
      if (typeof mainKey === &apos;object&apos;)
      {
         const options = {};

         options.mainKey = mainKey.mainKey || &apos;multistorage&apos;;
         options.session = mainKey.session || false;
         options.serializer = mainKey.serializer;

         this._params =
         {
            mainKey: options.mainKey,
            storageType: options.session ? &apos;sessionStorage&apos; : &apos;localStorage&apos;,
            serializer: options.serializer
         };
      }
      else
      {
         this._params =
         {
            mainKey,
            storageType: session ? &apos;sessionStorage&apos; : &apos;localStorage&apos;,
            serializer
         };
      }

      if (!s_STORAGE_AVAILABLE(this.storageType))
      {
         throw new Error(`Storage type &apos;${this.storageType} not available.`);
      }

      this._params.storage = window[this._params.storageType];
   }

   /**
    * Clears all entries associated with `mainKey`.
    *
    * @returns {Promise.&lt;boolean&gt;}
    */
   clear()
   {
      const storage = this._params.storage;
      storage.removeItem(this.mainKey);
      return Promise.resolve(true);
   }

   /**
    * Deletes entry filed under `key` in `mainKey` hash.
    *
    * @param {string}   key - Key to delete.
    * @returns {Promise.&lt;boolean&gt;}
    */
   delete(key)
   {
      const mainKey = this.mainKey;
      const serializer = this.serializer;
      const storage = this._params.storage;

      const storeJSON = storage.getItem(mainKey);
      if (typeof storeJSON === &apos;string&apos;)
      {
         const store = serializer.parse(storeJSON);
         delete store[key];
         storage[mainKey] = serializer.stringify(store);
      }
      return Promise.resolve(true);
   }

   /**
    * Returns the value associated with `key` in `mainKey` hash.
    *
    * @param {string}   key - Key to retrieve a value for.
    * @returns {Promise.&lt;undefined&gt;}
    */
   get(key)
   {
      const mainKey = this.mainKey;
      const serializer = this.serializer;
      const storage = this._params.storage;

      let returnValue = undefined;

      const storeJSON = storage.getItem(mainKey);
      if (typeof storeJSON === &apos;string&apos;)
      {
         const store = serializer.parse(storeJSON);
         returnValue = store[key];
      }

      return Promise.resolve(returnValue);
   }

   /**
    * Returns the entire JSON object stored by `mainKey`.
    *
    * @returns {Promise.&lt;undefined&gt;}
    */
   getStore()
   {
      const mainKey = this.mainKey;
      const serializer = this.serializer;
      const storage = this._params.storage;

      let returnValue = undefined;

      const storeJSON = storage.getItem(mainKey);
      if (typeof storeJSON === &apos;string&apos;)
      {
         returnValue = serializer.parse(storeJSON);
      }

      return Promise.resolve(returnValue);
   }

   /**
    * Sets a value by the give key in the `mainKey` hash.
    *
    * @param {string}   key - Key for indexed storage.
    * @param {*}        value - Any valid value to serialize.
    * @returns {Promise.&lt;boolean&gt;}
    */
   set(key, value)
   {
      const mainKey = this.mainKey;
      const serializer = this.serializer;
      const storage = this._params.storage;

      const storeJSON = storage.getItem(mainKey);
      const store = typeof storeJSON === &apos;string&apos; ? serializer.parse(storeJSON) : {};

      store[key] = value;

      storage.setItem(mainKey, serializer.stringify(store));

      return Promise.resolve(true);
   }

   /**
    * Sets an entire object to be serialized under `mainKey`.
    *
    * @param {*}  store - entire object store.
    * @returns {Promise.&lt;boolean&gt;}
    */
   setStore(store)
   {
      const mainKey = this.mainKey;
      const serializer = this.serializer;
      const storage = this._params.storage;

      storage.setItem(mainKey, serializer.stringify(store));

      return Promise.resolve(true);
   }
}

// Private internal methods -----------------------------------------------------------------------------------------

/**
 * Tests if the storage mechanism is available.
 *
 * @param {string}   type - Storage type.
 * @returns {boolean}
 */
const s_STORAGE_AVAILABLE = (type) =&gt;
{
   try
   {
      const storage = window[type], x = &apos;__storage_test__&apos;;
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
   }
   catch(err)
   {
      return false;
   }
};</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
